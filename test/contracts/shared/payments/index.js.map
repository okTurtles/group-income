{
  "version": 3,
  "sources": ["../../../../frontend/model/contracts/misc/flowTyper.js", "../../../../frontend/model/contracts/shared/payments/index.js"],
  "sourcesContent": ["// to make rollup happy, I copied flowTyper-js\n// library into this file (it was refusing to\n// import because of the way functions were being\n// exported).\n//\n// GI EDIT NOTES:\n//\n// - The following functions can be used directly with 'validate'\n//   because they've had their '_scope' second parameter removed:\n//   - arrayOf\n//   - mapOf\n//   - object\n//   - objectOf\n//   - objectMaybeOf (this is a custom function that didn't exist in flowTyper)\n//\n// TODO: remove this file from eslintIgnore in package.json and fix errors\n\n                                             \n                                           \n                                                \n                                                      \n                                                       \n                                                            \n                                                 \n\n                                \n                   \n                  \n \n\n                                   \n                   \n                   \n                  \n \n\n                                      \n                   \n                   \n                   \n                   \n \n\n                                         \n                   \n                   \n                   \n                   \n                  \n \n\nexport const EMPTY_VALUE = Symbol('@@empty')\nexport const isEmpty = v => v === EMPTY_VALUE\nexport const isNil = v => v === null\nexport const isUndef = v => typeof v === 'undefined'\nexport const isBoolean = v => typeof v === 'boolean'\nexport const isNumber = v => typeof v === 'number'\nexport const isString = v => typeof v === 'string'\nexport const isObject = v => !isNil(v) && typeof v === 'object'\nexport const isFunction = v => typeof v === 'function'\n\nexport const isType = typeFn => (v, _scope = '') => {\n  try {\n    typeFn(v, _scope)\n    return true\n  } catch (_) {\n    return false\n  }\n}\n\n// This function will return value based on schema with inferred types. This\n// value can be used to define type in Flow with 'typeof' utility.\nexport const typeOf = schema => schema(EMPTY_VALUE, '')\nexport const getType = (typeFn, _options) => {\n  if (isFunction(typeFn.type)) return typeFn.type(_options)\n  return typeFn.name || '?'\n}\n\n// error\nexport class TypeValidatorError extends Error {\n  expectedType        \n  valueType        \n  value        \n  typeScope        \n  sourceFile        \n\n  constructor (\n    message         ,\n    expectedType        ,\n    valueType        ,\n    value        ,\n    typeName         = '',\n    typeScope          = ''\n  ) {\n    const errMessage = message ||\n      `invalid \"${valueType}\" value type; ${typeName || expectedType} type expected`\n    super(errMessage)\n    this.expectedType = expectedType\n    this.valueType = valueType\n    this.value = value\n    this.typeScope = typeScope || ''\n    this.sourceFile = this.getSourceFile()\n    this.message = `${errMessage}\\n${this.getErrorInfo()}`\n    this.name = this.constructor.name\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, TypeValidatorError)\n    }\n  }\n\n  getSourceFile ()         {\n    const fileNames = this.stack.match(/(\\/[\\w_\\-.]+)+(\\.\\w+:\\d+:\\d+)/g) || []\n    return fileNames.find(fileName => fileName.indexOf('/flowTyper-js/dist/') === -1) || ''\n  }\n\n  getErrorInfo ()         {\n    return `\n    file     ${this.sourceFile}\n    scope    ${this.typeScope}\n    expected ${this.expectedType.replace(/\\n/g, '')}\n    type     ${this.valueType}\n    value    ${this.value}\n`\n  }\n}\n\n// TypeValidatorError.prototype.name = 'TypeValidatorError'\n// exports.TypeValidatorError = TypeValidatorError\n\nconst validatorError =    (\n  typeFn                  ,\n  value       ,\n  scope         ,\n  message         ,\n  expectedType         ,\n  valueType         \n)                     => {\n  return new TypeValidatorError(\n    message,\n    expectedType || getType(typeFn),\n    valueType || typeof value,\n    JSON.stringify(value),\n    typeFn.name,\n    scope\n  )\n}\n\nexport const arrayOf =\n     (typeFn                  , _scope          = 'Array')                        => {\n    function array (value) {\n      if (isEmpty(value)) return [typeFn(value)]\n      if (Array.isArray(value)) {\n        let index = 0\n        return value.map(v => typeFn(v, `${_scope}[${index++}]`))\n      }\n      throw validatorError(array, value, _scope)\n    }\n    array.type = () => `Array<${getType(typeFn)}>`\n    return array\n  }\n\nexport const literalOf =\n                   (primitive   )                   => {\n    function literal (value, _scope = '') {\n      if (isEmpty(value) || (value === primitive)) return primitive\n      throw validatorError(literal, value, _scope)\n    }\n    literal.type = () => {\n      if (isBoolean(primitive)) return `${primitive ? 'true' : 'false'}`\n      else return `\"${primitive}\"`\n    }\n    return literal\n  }\n\nexport const mapOf =       (\n  keyTypeFn                  ,\n  typeFn                  \n)                            => {\n  function mapOf (value) {\n    if (isEmpty(value)) return {}\n    const o = object(value)\n    const reducer = (acc, key) =>\n      Object.assign(\n        acc,\n        {\n          // $FlowFixMe\n          [keyTypeFn(key, 'Map[_]')]: typeFn(o[key], `Map.${key}`)\n        }\n      )\n    return Object.keys(o).reduce(reducer, {})\n  }\n  mapOf.type = () => `{ [_:${getType(keyTypeFn)}]: ${getType(typeFn)} }`\n  return mapOf\n}\n\nconst isPrimitiveFn = (typeName) =>\n  ['undefined', 'null', 'boolean', 'number', 'string'].includes(typeName)\n\nexport const maybe =\n     (typeFn                  )                        => {\n    function maybe (value, _scope = '') {\n      return (isNil(value) || isUndef(value)) ? value : typeFn(value, _scope)\n    }\n    maybe.type = () => !isPrimitiveFn(typeFn.name) ? `?(${getType(typeFn)})` : `?${getType(typeFn)}`\n    return maybe\n  }\n\nexport const mixed = (\n  function mixed (value) {\n    return value\n  }                  \n)\n\nexport const object = (\n  function (value) {\n    if (isEmpty(value)) return {}\n    if (isObject(value) && !Array.isArray(value)) {\n      return Object.assign({}, value)\n    }\n    throw validatorError(object, value)\n  }                                    \n)\n\nexport const objectOf =                            \n  (typeObj   , _scope          = 'Object')                                                        => {\n  function object2 (value) {\n    const o = object(value)\n    const typeAttrs = Object.keys(typeObj)\n    const unknownAttr = Object.keys(o).find(attr => !typeAttrs.includes(attr))\n    if (unknownAttr) {\n      throw validatorError(\n        object2,\n        value,\n        _scope,\n        `missing object property '${unknownAttr}' in ${_scope} type`\n      )\n    }\n    const undefAttr = typeAttrs.find(property => {\n      const propertyTypeFn = typeObj[property]\n      return (propertyTypeFn.name === 'maybe' && !o.hasOwnProperty(property))\n    })\n    if (undefAttr) {\n      throw validatorError(\n        object2,\n        o[undefAttr],\n        `${_scope}.${undefAttr}`,\n        `empty object property '${undefAttr}' for ${_scope} type`,\n        `void | null | ${getType(typeObj[undefAttr]).substr(1)}`,\n        '-'\n      )\n    }\n\n    const reducer = isEmpty(value)\n      ? (acc, key) => Object.assign(acc, { [key]: typeObj[key](value) })\n      : (acc, key) => {\n        const typeFn = typeObj[key]\n        if (typeFn.name === 'optional' && !o.hasOwnProperty(key)) {\n          return Object.assign(acc, {})\n        } else {\n          return Object.assign(acc, { [key]: typeFn(o[key], `${_scope}.${key}`) })\n        }\n      }\n    return typeAttrs.reduce(reducer, {})\n  }\n  object2.type = () => {\n    const props = Object.keys(typeObj).map(\n      (key) => typeObj[key].name === 'optional'\n        ? `${key}?: ${getType(typeObj[key], { noVoid: true })}`\n        : `${key}: ${getType(typeObj[key])}`\n    )\n    return `{|\\n ${props.join(',\\n  ')} \\n|}`\n  }\n  return object2\n}\n\n// TODO: add flow type annotations and make it use validatorError etc.\nexport function objectMaybeOf (validations        , _scope          = 'Object')         {\n  return function (data     ) {\n    object(data)\n    for (const key in data) {\n      validations[key]?.(data[key], `${_scope}.${key}`)\n    }\n    return data\n  }\n}\n\nexport const optional =\n     (typeFn                  )                          => {\n    const unionFn = unionOf(typeFn, undef)\n    function optional (v) {\n      return unionFn(v)\n    }\n    optional.type = ({ noVoid }) => !noVoid ? getType(unionFn) : getType(typeFn)\n    return optional\n  }\n\nexport const nil = (\n  function nil (value) {\n    if (isEmpty(value) || isNil(value)) return null\n    throw validatorError(nil, value)\n  }\n                       \n)\n\nexport function undef (value, _scope = '') {\n  if (isEmpty(value) || isUndef(value)) return undefined\n  throw validatorError(undef, value, _scope)\n}\nundef.type = () => 'void'\n// export const undef = (undef: TypeValidator<void>)\n\nexport const boolean = (\n  function boolean (value, _scope = '') {\n    if (isEmpty(value)) return false\n    if (isBoolean(value)) return value\n    throw validatorError(boolean, value, _scope)\n  }\n                          \n)\n\nexport const number = (\n  function number (value, _scope = '') {\n    if (isEmpty(value)) return 0\n    if (isNumber(value)) return value\n    throw validatorError(number, value, _scope)\n  }\n                         \n)\n\nexport const string = (\n  function string (value, _scope = '') {\n    if (isEmpty(value)) return ''\n    if (isString(value)) return value\n    throw validatorError(string, value, _scope)\n  }\n                         \n)\n\n                            \n             \n                                     \n                                                 \n                                                             \n                                                                         \n                                                                                     \n                                                                                                 \n                                                                                                             \n                                                                                                                         \n                                                                                                                                     \n                                                                                                                                                 \n\nfunction tupleOf_ (...typeFuncs) {\n  function tuple (value       , _scope = '') {\n    const cardinality = typeFuncs.length\n    if (isEmpty(value)) return typeFuncs.map(fn => fn(value))\n    if (Array.isArray(value) && value.length === cardinality) {\n      const tupleValue = []\n      for (let i = 0; i < cardinality; i += 1) {\n        tupleValue.push(typeFuncs[i](value[i], _scope))\n      }\n      return tupleValue\n    }\n    throw validatorError(tuple, value, _scope)\n  }\n  tuple.type = () => `[${typeFuncs.map(fn => getType(fn)).join(', ')}]`\n  return tuple\n}\n\n// $FlowFixMe - $Tuple<(A, B, C, ...)[]>\n// const tupleOf: TupleT = tupleOf_\nexport const tupleOf = tupleOf_\n\n             \n                                   \n                                                \n                                                             \n                                                                          \n                                                                                       \n                                                                                                    \n                                                                                                                 \n                                                                                                                              \n                                                                                                                                           \n                                                                                                                                                        \n\nfunction unionOf_ (...typeFuncs) {\n  function union (value       , _scope = '') {\n    for (const typeFn of typeFuncs) {\n      try {\n        return typeFn(value, _scope)\n      } catch (_) {}\n    }\n    throw validatorError(union, value, _scope)\n  }\n  union.type = () => `(${typeFuncs.map(fn => getType(fn)).join(' | ')})`\n  return union\n}\n// $FlowFixMe\n// const unionOf: UnionT = (unionOf_)\nexport const unionOf = unionOf_\n", "'use strict'\n\nimport { unionOf, literalOf } from '~/frontend/model/contracts/misc/flowTyper.js'\n\nexport const PAYMENT_PENDING = 'pending'\nexport const PAYMENT_CANCELLED = 'cancelled'\nexport const PAYMENT_ERROR = 'error'\nexport const PAYMENT_NOT_RECEIVED = 'not-received'\nexport const PAYMENT_COMPLETED = 'completed'\nexport const paymentStatusType         = unionOf(...[PAYMENT_PENDING, PAYMENT_CANCELLED, PAYMENT_ERROR, PAYMENT_NOT_RECEIVED, PAYMENT_COMPLETED].map(k => literalOf(k)))\nexport const PAYMENT_TYPE_MANUAL = 'manual'\nexport const PAYMENT_TYPE_BITCOIN = 'bitcoin'\nexport const PAYMENT_TYPE_PAYPAL = 'paypal'\nexport const paymentType         = unionOf(...[PAYMENT_TYPE_MANUAL, PAYMENT_TYPE_BITCOIN, PAYMENT_TYPE_PAYPAL].map(k => literalOf(k)))\n"],
  "mappings": "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",
  "names": []
}

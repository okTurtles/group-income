# Information Flow

It's recommended that you understand the [basics of `sbp`](https://github.com/okTurtles/sbp-js) before moving on because everything below relies on it.

In Group Income, we use a framework for building software out of something called "contract chains" (if you're familiar with how smart contracts in Ethereum work, this will make more sense to you).

A contract chain is an immutable linked-list of events. We use this sequence of events to build up a state. For example, in Group Income we have a "group contract" that represents everything happening within a single group. The first event in the contract defines and registers the contract itself, in this case, the specific instance of a group. Each subsequent event represents an action that happens within the group.

So for example, if we want to update the settings of a group, we do this:

```js
// Example: Update a group minimum income to 150

await sbp('gi.actions/group/updateSettings', {
  contractID: this.currentGroupId, data: { mincomeAmount: 150 }
})
```

This action accomplishes two things at once:

1. It creates the event â€” an *action* â€” and wraps it in a [`GIMessage`](../shared/GIMessage.js) object.
2. It sends this `GIMessage` to the server - appending it to the contract `contractID` (in this case, the current group we're in)

> _Contracts_ can be thought of as *distributed classes*. When you create a contract, you create an *instance*, similarly to how instances in [OOP](https://en.wikipedia.org/wiki/Object-oriented_programming) can be created. Contracts have an internal state that is updated by *actions*. A contract can be a group, a user profile (identity), or any other thing. All current contracts can be found at [`frontend/model/contracts/`](../frontend/model/contracts/).

##### Data Representation

`GIMessages`, and in fact all data in Group Income, is referenced by its hash, and on the server, stored in a file with a file name that is equal to that hash. Retrieving that data then becomes a simple hash lookup, similar to how IPFS and the Dat Protocol work.

##### Actions

All of the contract actions for all the contracts used in Group Income are defined in [`frontend/controller/actions/`](..frontend/controller/actions/).

##### Client <-> Server Communication Details

When a client sends a `GIMessage` to a contract stored on the server, that message is sent back (via websockets) to everyone who is subscribed to that contract, including the client that sent the message. Upon receiving this message/event, each client uses it to update their local copy of the contract state, per the `process` function that is defined for that action. All of these `process` functions can be found in [`frontend/model/contracts/`](../frontend/model/contracts/).

##### Vuex Integration

In Group Income, we integrate our contract framework with Vuex, and the logic for that integration can be found in [`frontend/model/state.js`](../frontend/model/state.js).

This allows the UI to be automatically updated whenever an action is sent to the contract. Our framework even supports Vuex-like getters, that can be directly bound to the UI.

###### The `process` function

Whenever a message is received by a client, it is first processed through the Vuex action `handleEvent` in [`frontend/model/state.js`](../frontend/model/state.js).

From there is sent to our framework and contract logic. In most cases, a normal non-async function is called, call the `process` function. This processes the message and applies the logic to update the state based on the action name and any data that is associated with it.

In our example above, the name of the *contract action* generated by `sbp('gi.actions/group/updateSettings', ...)` is called `'gi.contracts/group/updateSettings'`, and its `process` function is defined in [`frontend/model/contracts/group.js`](../frontend/model/contracts/group.js):

```js
'gi.contracts/group/updateSettings': {
  validate: objectMaybeOf({
    groupName: x => typeof x === 'string',
    groupPicture: x => typeof x === 'string',
    sharedValues: x => typeof x === 'string',
    mincomeAmount: x => typeof x === 'number' && x > 0,
    mincomeCurrency: x => typeof x === 'string'
  }),
  process ({ meta, data }, { state, getters }) {
    for (const key in data) {
      Vue.set(state.settings, key, data[key])
    }
  }
},
```

> **Note**: Metadata is only included when contracts define a metadata key in their contract definition. It includes information about the action, such as when it was created and who created it.

##### Subscribing to a contract

Subscribing to a contract is done by calling either of these selectors: `'gi.actions/contract/sync'` or `'gi.actions/contract/syncAndWait'`

For example:

```js
sbp('gi.actions/contract/sync', contractId)

// OR

await sbp('gi.actions/contract/syncAndWait', contractId)
```

These selectors will subscribe us to the contract and begin listening for new updates.

(...WIP...)

When subscribed to a Contract, the user is updated each time an action there is called, even if the action wasn't triggered by the user itself. (TODO: Add link/reference to where this happens)

So you don't need to worry about this for now, it just works ðŸ”®.


That's all for now! Feel free to dive even more deeply in the files mentioned so far and complement these docs with your discoveries.
